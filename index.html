<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>University of Ottawa Colloquium in Mathematics and Statistics</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="index_files/libs/clipboard/clipboard.min.js"></script>
<script src="index_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="index_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="index_files/libs/quarto-html/popper.min.js"></script>
<script src="index_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="index_files/libs/quarto-html/anchor.min.js"></script>
<link href="index_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="index_files/libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="index_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="index_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="index_files/libs/bootstrap/bootstrap-bb462d781dde1847d9e3ccf7736099dd.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


<link rel="stylesheet" href="styles/custom.css">
</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">University of Ottawa Colloquium in Mathematics and Statistics</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div class="logos">
<p><img src="logos/uo.png"> <img src="logos/crm.png"> <img src="logos/timc.png"></p>
</div>
<p>Welcome to the University of Ottawa Colloquium in Mathematics and Statistics (UOCMS). This series brings together researchers from diverse institutions to present lectures on current developments in mathematics and statistics.</p>
<section id="fall-2025" class="level1">
<h1>Fall 2025</h1>
<p><strong>Time:</strong> Thursdays, 1:00–2:00 pm<br>
<strong>Location:</strong> University of Ottawa, STEM building, room 664 (unless otherwise specified)<br>
<a href="calendar/uocms_fall2025.ics">Add to Calendar</a></p>
<section id="upcoming-lectures" class="level2">
<h2 class="anchored" data-anchor-id="upcoming-lectures">Upcoming Lectures</h2>
<p><strong>Speaker:</strong> <a href="https://mast.queensu.ca/~gmazzone/index.html">Giusy Mazzone</a>, Queen’s University<br>
<strong>Date:</strong> October 16, 2025<br>
<strong>Title:</strong> On the Mathematical Analysis of Fluid–Solid Interaction Problems<br>
<strong>Abstract:</strong> I will present several models describing the interactions between viscous incompressible fluids and solids, which may be either rigid or deformable. The governing equations for these interactions consist of the Navier–Stokes equations coupled with either the Euler equations for rigid body dynamics or the Navier equations of linearized elasticity. A common feature of these problems is that the governing equations have a dissipative—conservative (parabolic—hyperbolic) structure: while the fluid introduces dissipation in the mechanical energy of the coupled system, the solid contributes to the same energy with a conservative (more generally, non-decreasing) component. From a mathematical perspective, this interplay poses significant challenges when establishing the existence and stability of solutions to the governing equations. I will provide an overview of my contributions to the analysis of these problems for various mechanical systems involving fluid–solid interactions.</p>
<hr>
<p><strong>Speaker:</strong> <a href="https://personal.math.ubc.ca/~adem/">Alejandro Adem</a>, University of British Columbia<br>
<strong>Date:</strong> October 23, 2025<br>
<strong>Title:</strong> Topology and Symmetries<br>
<strong>Abstract:</strong> In this lecture we will discuss how methods from algebraic topology can be applied to shed light on fundamental questions related to finite group actions. We will start with basic invariants such as the Euler characteristic and explore classical applications such as topological space forms as well as more recent work about actions on 4-dimensional manifolds (joint with I. Hambleton). This will be illustrated with a variety of examples, as well as some open problems.</p>
<hr>
<p><strong>Speaker:</strong> <a href="https://scholar.google.com/citations?user=Ry3IviAAAAAJ&amp;hl=de">Florian Dumpert</a>, Federal Statistical Office of Germany<br>
<strong>Date:</strong> October 30, 2025<br>
<strong>Location:</strong> Exceptionally, this colloquium will take place in STEM 464.</p>
<hr>
<p><strong>Speaker:</strong> <a href="https://www.math.toronto.edu/quastel/">Jeremy Quastel</a>, University of Toronto<br>
<strong>Date:</strong> November 6, 2025</p>
<hr>
<p><strong>Speaker:</strong> <a href="https://sites.google.com/view/bruno-feunou/home">Bruno Feunou Kamkui</a>, Bank of Canada<br>
<strong>Date:</strong> November 13, 2025</p>
<hr>
<p><strong>Speaker:</strong> <a href="https://www.wlu.ca/academics/faculties/faculty-of-science/faculty-profiles/mark-reesor/index.html">Mark Reesor</a>, Wilfrid Laurier University<br>
<strong>Date:</strong> November 20, 2025</p>
<hr>
<p><strong>Speaker:</strong> <a href="https://www.math.mcgill.ca/atserunyan/">Anush Tserunyan</a>, McGill University<br>
<strong>Date:</strong> December 4, 2025</p>
<hr>
</section>
<section id="past-lectures" class="level2">
<h2 class="anchored" data-anchor-id="past-lectures">Past Lectures</h2>
<p><strong>Speaker:</strong> <a href="https://jhom6.math.gatech.edu/">Jen Hom</a>, Georgia Institute of Technology<br>
<strong>Title:</strong> 3-Manifolds, Groups, and Heegaard Floer Homology<br>
<strong>Date:</strong> October 2, 2025<br>
<strong>Location:</strong> Exceptionally, this colloquium will take place in STEM 464.<br>
<strong>Abstract:</strong> We will consider various ways to build 3-manifolds. Under the operation of connected sum, the set of 3-manifolds forms a monoid, and modulo an appropriate equivalence relation, this monoid becomes a group. What is the structure of this group? What families of three-manifolds generate (or don’t generate) this group? We give some answers to these questions using Heegaard Floer homology. This is joint work with (various subsets of) I. Dai, K. Hendricks, M. Stoffregen, L. Truong, and I. Zemke.</p>
<hr>
<p><strong>Speaker:</strong> <a href="https://scholar.google.com/citations?user=QyoI7fQAAAAJ&amp;hl=en">Sumiya Baasandorj</a>, University of Ottawa<br>
<strong>Title:</strong> Regularity for a Class of (Non)Variational Problems with (Non)Standard Growth<br>
<strong>Date:</strong> September 25, 2025<br>
<strong>Abstract:</strong> Regularity issues in (non)variational problems with (non)standard growth have been a central topic of analysis, witnessing tremendous development over the past century. Regularity techniques ultimately aim to show that suitable weak or distributional solutions are, in fact, classical solutions. In this talk, I will present some recent regularity results for a class of variational functionals with nonstandard growth conditions, namely the so-called Orlicz double phase functional. This will involve revisiting the fundamental contributions of De Giorgi and Nash and connecting them with recent advances in nonuniformly elliptic problems. Furthermore, I will try to give an overview of the regularity theory for nonvariational elliptic problems, such as the Monge–Amp`ere equation, and discuss its connections to optimal transport theory.<br>
<a href="slides/Baasandorj.pdf">Lecture slides</a></p>
<hr>
<p><strong>Speaker:</strong> <a href="https://sites.google.com/view/emanuelenaldi/home-page">Emanuele Naldi</a>, University of Genoa<br>
<strong>Title:</strong> <a href="https://arxiv.org/abs/2505.23517">Inexact Jordan–Kinderlehrer–Otto and Proximal-Gradient Algorithms in the Wasserstein Space: Links and Differences from the Hilbert Case</a><br>
<strong>Date:</strong> September 18, 2025<br>
<strong>Abstract:</strong> In this talk, we explore the asymptotic convergence properties of inexact Jordan–Kinderlehrer–Otto (JKO) scheme and proximal-gradient algorithm in the Wasserstein space. While the classical JKO scheme assumes exact minimization at each step, practical implementations rely on approximate solutions due to computational constraints. We analyze two types of inexactness: errors in Wasserstein distance and errors in functional evaluations. We establish rigorous convergence guarantees under controlled error conditions. Beyond the inexact setting, we also extend the convergence results by considering varying stepsizes. Our analysis expands previous approaches, providing new insights into discrete Wasserstein gradient flows. We finish the talk with a comparison to the Hilbert space setting, where the proximity operator is nonexpansive, a property that plays a central role in many classical convergence results. In the Wasserstein setting, the nonexpansivity of the proximity operator generally fails, even for geodesically convex functionals. We discuss the class of functions for which this property still holds and highlight potential directions for future research.<br>
<a href="slides/Naldi.pdf">Lecture slides</a></p>
<hr>
<p><strong>Speaker:</strong> <a href="https://www.nottingham.ac.uk/mathematics/people/susanne.pumpluen">Susanne Pumplün</a>, University of Nottingham<br>
<strong>Title:</strong> <a href="https://arxiv.org/html/2508.06695v1">On Skew Constacyclic Codes and their Surprising Connection to Nonassociative Algebra</a><br>
<strong>Date:</strong> September 11, 2025<br>
<strong>Abstract:</strong> Cyclic, constacyclic and skew constacyclic codes are some of the most important and most investigated classes of linear codes (some are now also being used to build quantum error-correcting codes). Their cyclic structure allows us to characterize them using polynomials or skew polynomials, and to describe them as ideals in an algebra. More precisely, each codeword corresponds to a (skew) polynomial in a suitable chosen ideal of its ambient algebra. This ambient algebra may, however, be not associative. This is not well known, as all approaches so far only worked with associative ambient algebras or divert to ambient submodules. In the first part of the talk we will thus set up a cohesive theory that includes the nonassociative case. In the second part, we will address the problem how to classify skew constacyclic codes using the isomorphisms of their ambient algebras. We propose a new definition of equivalence that will result in tighter code classifications than previously presented ones, and will help to de-duplicate codes with the same performance paramenters. We prove with combinatorial methods that the notions of isometry and equivalence defined by Ou-azzou et al.&nbsp;(2025) coincide when the ambient algebras are not associative.<br>
<a href="slides/Pumpluen.pdf">Lecture slides</a></p>
<hr>
<p><strong>Speaker:</strong> <a href="https://sites.google.com/view/bartoluccifrancesca">Francesca Bartolucci</a>, Delft University of Technology<br>
<strong>Title:</strong> <a href="https://arxiv.org/abs/2305.19913">Representation Equivalent Neural Operators: A Framework for Alias-Free Operator Learning</a><br>
<strong>Date:</strong> September 4, 2025<br>
<strong>Abstract:</strong> Recently, operator learning, or learning mappings between infinite-dimensional function spaces, has garnered significant attention, notably in relation to learning partial differential equations from data. Conceptually clear when outlined on paper, neural operators require discretization in the transition to computer implementations. This step can compromise their integrity, often causing them to deviate from the underlying operators. This research offers a fresh take on neural operators with a Representation equivalent Neural Operators (ReNO) framework designed to address these issues. At its core is the concept of operator aliasing, which measures inconsistency between neural operators and their discrete representations. More generally, this framework not only sheds light on existing challenges but, given its constructive and broad nature, also potentially offers tools for developing new neural operators. This is a joint work with Rima Alaifari, Emmanuel de Bézenac, Siddhartha Mishra, Roberto Molinaro and Bogdan Raonić.<br>
<a href="slides/Bartolucci.pdf">Lecture slides</a></p>
<hr>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>